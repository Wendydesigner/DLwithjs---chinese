(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{220:function(i,e,t){"use strict";t.r(e);var l=t(0),n=Object(l.a)({},(function(){var i=this,e=i.$createElement,t=i._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":i.$parent.slotKey}},[t("h1",{attrs:{id:"_2-5-练习"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-5-练习"}},[i._v("#")]),i._v(" 2.5 练习")]),i._v(" "),t("ol",[t("li",[i._v("波士顿房屋问题创建的神经网络具有两个隐藏层的模型。鉴于我们所说的级联非线性函数会导致模型容量增加，是否可以在模型中添加更多隐藏层来提高评估精度？通过修改 index.js 并重新运行训练和评估来进行尝试。")]),i._v(" "),t("li",[i._v("一种影响隐藏层提高评估准确性的因素是什么？")]),i._v(" "),t("li",[i._v("是什么使您得出这个结论？（提示：查看训练集上的错误。）")]),i._v(" "),t("li",[i._v("查看清单 3.5 中的代码如何在每个训练时期的开始使用 onEpochBegin 回调函数来计算和绘制 ROC 曲线。您是否可以遵循这种模式并对回调函数的主体进行一些修改，以便可以在每个时期的开始时打印精度和调用值（根据测试集计算）？描述这些值如何随着训练的进行而变化。")]),i._v(" "),t("li",[i._v("研究清单 3.6 中的代码，并了解它如何计算 ROC 曲线。您能否遵循此示例并编写一个名为“ drawPrecisionRecallCurve ” 的新函数，顾名思义，该函数可以计算并渲染 precision-recall 曲线？编写完函数后，请从 onEpochBegin 回调中调用它，以便可以在每个训练时期的开始沿 ROC 曲线绘制 precision-recall 曲线。您可能需要对 ui.js 进行一些更改或添加。")]),i._v(" "),t("li",[i._v("假设您被告知二分类器结果的假阳性率和真阳性率。使用这两个数字，您可以计算出整体准确度吗？如果不能，您还需要什么其他信息？")]),i._v(" "),t("li",[i._v("二进制交叉熵（第 3.2.4 节）和分类交叉熵（第 3.3.3 节）的定义均基于自然对数（即以 e 为底的对数）。如果我们更改定义以使他们使用以 10 为底的对数怎么办？对二进制和多分类器的训练和推理有什么影响？")]),i._v(" "),t("li",[i._v("将清单 3.4 中用于超参数网格搜索的代码转换为实际的 JavaScript 代码，并使用该代码对清单 3.1 中的两层 Boston Housing 模型执行超参数优化。具体来说，调整隐藏层的单位数和学习率。随意赋值要搜索的单位数和学习率。请注意，机器学习工程师通常为这些搜索使用近似的几何序列（即对数）间距（例如，units= 2、5、10、20、50、100、200 等）。")])])])}),[],!1,null,null,null);e.default=n.exports}}]);